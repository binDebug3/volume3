import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import inv, norm

class KalmanFilter(object):
    def __init__(self,F,Q,H,R,u):
        """
        Initialize the dynamical system models.
        
        Parameters
        ----------
        F : ndarray of shape (n,n)
            The state transition model.
        Q : ndarray of shape (n,n)
            The covariance matrix for the state noise.
        H : ndarray of shape (m,n)
            The observation model.
        R : ndarray of shape (m,m)
            The covariance matric for observation noise.
        u : ndarray of shape (n,)
            The control vector.
        """
        raise NotImplementedError('Problem 1 Incomplete')
    
    def evolve(self,x0,N):
        """
        Compute the first N states and observations generated by the Kalman system.

        Parameters
        ----------
        x0 : ndarray of shape (n,)
            The initial state.
        N : integer
            The number of time steps to evolve.

        Returns
        -------
        states : ndarray of shape (n,N)
            The i-th column gives the i-th state.
        obs : ndarray of shape (m,N)
            The i-th column gives the i-th observation.
        """
        raise NotImplementedError('Problem 3 Incomplete')     

    def estimate(self,x0,P0,z, return_norms = False):
        """
        Compute the state estimates using the kalman filter.

        Parameters
        ----------
        x0 : ndarray of shape (n,)
            The initial state estimate.
        P0 : ndarray of shape (n,n)
            The initial error covariance matrix.
        z : ndarray of shape(m,N)
            Sequence of N observations (each column is an observation).

        Returns
        -------
        out : ndarray of shape (n,N)
            Sequence of state estimates (each column is an estimate).
        norms: list of floats of length N
            Gives the norm of the error matrix for each estimate.
        """
        raise NotImplementedError('Problem 4 Incomplete')  
            
    
    def predict(self,x,k):
        """
        Predict the next k states in the absence of observations.

        Parameters
        ----------
        x : ndarray of shape (n,)
            The current state estimate.
        k : integer
            The number of states to predict.

        Returns
        -------
        out : ndarray of shape (n,k)
            The next k predicted states.
        """
        raise NotImplementedError('Problem 6 Incomplete')  
    
    def rewind(self,x,k):
        """
        Predict the states from time 0 through k-1 in the absence of observations.
    
        Parameters
        ----------
        x : ndarray of shape (n,)
            The state estimate at time k.
        k : integer
            The current time step.
    
        Returns
        -------
        out : ndarray of shape (n,k)
            The predicted states from time 0 up through k-1 (in that order).
        """
        raise NotImplementedError('Problem 8 Incomplete')  


def problem2():
    """ 
    Instantiate and retrun a KalmanFilter object with the transition and observation 
    models F and H, along with the control vector u, corresponding to the 
    projectile. Assume that the noise covariances are given by
    Q = 0.1 · I4
    R = 5000 · I2.
    
    Return the KalmanFilter Object
    """
    raise NotImplementedError('Problem 2 Incomplete')  
    
    
def problem5():
    """
    Calculate an initial state estimate xb200. Using the initial state estimate, 
    P200 and your Kalman Filter, compute the next 600 state estimates. 
    Plot these state estimates as a smooth green
    curve together with the radar observations (as red dots) and the entire
    true state sequence (as blue curve).
    """
    raise NotImplementedError('Problem 5 Incomplete')      
    
    
def problem7():
    """
    Using the final state estimate xb800 that you obtained in Problem 5, 
    predict the future states of the projectile until it hits the ground. 
    Plot the actual state sequence together with the predicted state sequence 
    (as a yellow curve), and observe how near the prediction is to the actual 
    point of impact. Y
    """    
    raise NotImplementedError('Problem 7 Incomplete') 


def problem9():
    """
     Using your state estimate xb250, predict the point of origin of the 
     projectile along with all states leading up to time step 250. 
     Plot these predicted states (in cyan) together with the original state 
     sequence. Repeat the prediction starting with xb600. 
     """
    raise NotImplementedError('Problem 9 Incomplete')